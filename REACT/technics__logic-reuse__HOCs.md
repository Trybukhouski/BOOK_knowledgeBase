# HOCs

## About
- HOCs > High order components > Компоненты высшего порядка.
- Это функция, которая принимает компонент и возвращает новый компонент с расширенной логикой (или обновленной функциональностью).  
Добавленная в компонент логика (или функциональность) описывается в HOCе.
- [ Это функция для параметризованного создания контейнеров ]..

## Scope of use
- Добавление функциональности в компонент, не меняя его исходного кода.  
Позволяет сохранить универсальность исходного компонента.
- Создание и инкапсулирование функциональности (в HOCe) с последующим добавлием его в каждый из обернутых компонентов.  
Позволяет переиспользовать логику вместо дублирования.

## Сreation >> Global Rules
- HOC - чистая функция: не должна ничего менять и наследовать.
- Задача HOC - просто обернуть оригинальный компонент в контейнер посредством композиции. Оборачиваемый компонент не следует мутировать: менять прототип и др. ([ Работать с комозицией, а не прототипами ]..)
- Взаимодействие между ОК и HOC происходит через пропсы (также, как и между двумя компонентами).  
Пропсы, напрямую не связанные с HOC, должны передаваться в ОК без изменений.  
Рефы не передаются в ОК из HOC.
- НОС должен расширять функционал OK, но не менять его предназначения: расширенный интерфейс должен оставаться схожим  исходным.
- Максимизация композитивности ([Подробнее](https://ru.reactjs.org/docs/higher-order-components.html#convention-maximizing-composability))
- Не использовать HOC внутри рендер-методов:  
Сначала получаем компонент из HOC - потом его используем.  
Причины [>>](https://ru.reactjs.org/docs/higher-order-components.html#dont-use-hocs-inside-the-render-method)


## Creation >> Algorytm
1. Имеем оборачиваемый компонент

    ```
    <OurComponent/>
    ```
1. Реализуем HOC:
    1. Создаем  стандартную функцию.
    1. В функции создаем анонимный компонент и возвращаем его.
    1. Передаем в функцию аргумент, означающий оборачиваемый компонент.  
    Функция может принимать любые другие необходимые ей аргументы.
    1. Внутри компонента реализуем логику, которая будет расширять оборачиваемый компонент.
    1. Копируем статические методы ОК в HOC.  
    По умолчанию статические методы OK не становятся таковыми у HOC.  
    Техники копирования [>>](https://ru.reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over)
    1. Внутри компонента указываем отображаемое в консоли имя для HOC (*);

    ```
    function ourComponentWithHOC(WrapedComponent, otherArgs) {
      return class extends React.Component {
        OurComponentWithHOC.displayName = `name`  // *
        // some logic
        render() {
          return (
            // UI
          )
        }
      }
    }
    ```
1. Создаем экземпляр оборачиваемого компонента, расширенного при помощи HOCa.

    ```
    const EnhancedComponent = ourComponentWithHOC(OurComponent);
    ```
1. Используем расширенный компонент в UI

    ```
    <EnhancedComponent/>
    ```

## Practice examples
- example-1 >>
- Прелодер >> _Сделать по [ссылке](https://www.youtube.com/watch?v=POHukHTiEL4)_

## ToDo
- _В раздел technics-of-logic-reuse_
- Изучить, что такое компоненты-контейнеры.