# CREATION >> APP

## Common settings
1. Устанавливаем redux-пакет:
    ```
    npm i redux
    ```
    - Пакет инициализирует функцию `createStore()`, создающую `store`.
    - Также функцию `createStore()` можно создать "вручную", не используя пакет. (об этом - отдельный раздел в Creation)
1. Создаем функцию `reducer()`, меняющую `state` на основании конкретного `àction.type`.
1. В [ главном файле? ].. приложения создается переменная `store`, которой приваивается вызов функции `createStore()`.  
В качестве аргументов мы передаем [ актуальный `reducer` и `initialState` ]..подробнее.
1. В результате мы имеем объект со следующими методами:
    - `dispatch()`
    - `subscribe()`
    - `getState()`  
    Возвращает текущее состояние.

## Component settings
1. В компонент [ импортируем? ].. `store`
1. В обработчиках событий компонента указываем, что событие должно обновить `state` через `store.dispatch()` на основании переданного аргументом `action` c конкретным типом.  
Т.е. мы не обновляем компонент напрямую, а обращаемся к конкретному `action.type`, у которого есть 'договоренность' с `reducer` об обновлении `state` определенным образом.  
Синтаксис:

    ```
    btn.addEventListener('click', () => {
      store.dispatch({type: 'INCREMENT'})
    })
    ```
1. Указываем, как необходимо перерисовать компонент, исходя из того, что `state` обновился.
    - обращаемся в компоненте к методу `state.subscribe(callback)`
    - в качестве `callback-функции` указываем, как конкретно необходимо перерисовать компонент.

        ```
        store.subscribe(() => {
          const state = store.getState();
          count.textContent = state;
        })
        ```
1. Указываем изначальное значение компонента (значение до внесения изменений через `state`):
    - обращаемся в комопненте к методу `store.dispatch()` которому передаем `action` с `type: 'INIT_APPICATION'`.  
    Т.к. данного типа `action` не существует, метод `state.subscribe(callback)` установит изначальное значение, указанное при инициализации `store`.